import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { useToast } from '@/hooks/use-toast';
import { useCalendarEvents } from '@/hooks/useCalendarEvents';
import { getUserTimeZone } from '@/utils/timeZoneUtils';
import { createWeeklyRule } from '@/utils/rruleUtils';
import { ICalendarEvent } from '@/types/calendar';
import { format } from 'date-fns';
import { useGoogleCalendar } from '@/hooks/useGoogleCalendar';
import { useUser } from '@/context/UserContext';
import { useTimeZone } from '@/context/TimeZoneContext';

interface AvailabilityContextType {
  events: any[];
  isLoading: boolean;
  isInitialized: boolean;
  refreshEvents: () => void;
  addAvailabilitySlot: (dayIndex: number, startTime: string, endTime: string) => Promise<void>;
  updateAvailabilitySlot: (eventId: string, startTime: string, endTime: string) => Promise<void>;
  removeAvailabilitySlot: (eventId: string) => Promise<void>;
  
  // Google Calendar integration
  isGoogleLinked: boolean;
  isGoogleAuthenticated: boolean;
  connectGoogleCalendar: () => Promise<void>;
  disconnectGoogleCalendar: () => Promise<void>;
  syncWithGoogleCalendar: () => Promise<void>;
  isSyncing: boolean;
  lastSyncTime: Date | null;
  
  // Added properties
  hasNoEvents: boolean;
  error: Error | null;
}

const AvailabilityContext = createContext<AvailabilityContextType | undefined>(undefined);

export const AvailabilityProvider: React.FC<{ clinicianId: string | null; children: React.ReactNode }> = ({ 
  clinicianId, 
  children 
}) => {
  const [userTimeZone, setUserTimeZone] = useState(getUserTimeZone());
  const [hasNoEvents, setHasNoEvents] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);
  const { toast } = useToast();
  const { isLoading: isUserLoading, userId } = useUser();
  const { userTimeZone: contextTimeZone, isLoading: isTimeZoneLoading, isAuthenticated } = useTimeZone();
  
  // Wait for user and timezone data to be ready
  useEffect(() => {
    if (!isUserLoading && !isTimeZoneLoading && contextTimeZone) {
      setUserTimeZone(contextTimeZone);
      setIsInitialized(true);
      console.log('[AvailabilityContext] Initialized with timezone:', contextTimeZone);
    }
  }, [isUserLoading, isTimeZoneLoading, contextTimeZone]);
  
  const {
    events,
    isLoading,
    error,
    refetch: refreshEvents,
    createEvent,
    updateEvent,
    deleteEvent
  } = useCalendarEvents({
    clinicianId,
    userTimeZone,
    showAvailability: true
  });
  
  // Set hasNoEvents flag when events are loaded and array is empty
  useEffect(() => {
    if (!isLoading && Array.isArray(events) && events.length === 0) {
      setHasNoEvents(true);
      console.log('[AvailabilityContext] No events found, setting hasNoEvents flag');
    } else if (Array.isArray(events) && events.length > 0) {
      setHasNoEvents(false);
    }
  }, [events, isLoading]);
  
  // Initialize Google Calendar integration
  const {
    isGoogleLinked,
    isAuthenticated: isGoogleAuthenticated,
    isSyncing,
    lastSyncTime,
    signIn: connectGoogleCalendar,
    signOut: disconnectGoogleCalendar,
    syncCalendar: syncWithGoogleCalendar,
    addEvent: addGoogleEvent,
    updateEvent: updateGoogleEvent,
    deleteEvent: deleteGoogleEvent,
  } = useGoogleCalendar({
    clinicianId,
    userTimeZone,
    onSyncComplete: refreshEvents,
    onSyncError: (error) => {
      toast({
        title: "Sync Error",
        description: "Failed to sync with Google Calendar: " + error.message,
        variant: "destructive",
      });
    }
  });
  
  const addAvailabilitySlot = useCallback(async (dayIndex: number, startTime: string, endTime: string) => {
    if (!clinicianId) {
      console.error("[AvailabilityContext] No clinician selected");
      toast({
        title: "Error",
        description: "No clinician selected",
        variant: "destructive",
      });
      return;
    }
    
    if (!isInitialized || !isAuthenticated) {
      console.error("[AvailabilityContext] Not initialized or not authenticated");
      toast({
        title: "Error",
        description: "Please wait until authentication is complete",
        variant: "destructive",
      });
      return;
    }
    
    try {
      console.log(`Creating availability slot for clinician ${clinicianId} on day ${dayIndex}`);
      
      // Create a new weekly availability event
      const today = new Date();
      const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayIndex];
      
      // Create start and end times for today as reference points
      const startISO = `${format(today, 'yyyy-MM-dd')}T${startTime}:00`;
      const endISO = `${format(today, 'yyyy-MM-dd')}T${endTime}:00`;
      
      console.log(`Creating event with start time ${startISO} and end time ${endISO}`);
      
      // Create the event
      const availabilityEvent: ICalendarEvent = {
        id: '', // Will be generated by the service
        clinicianId,
        title: `Available - ${dayName}`,
        startTime: startISO,
        endTime: endISO,
        allDay: false,
        eventType: 'availability',
        recurrenceRule: {
          id: '', // Will be generated
          eventId: '', // Will be set after event creation
          rrule: createWeeklyRule(dayIndex)
        }
      };
      
      console.log("Creating availability event:", availabilityEvent);
      
      // Add to local and Google calendar if linked
      let createdEvent;
      if (isGoogleLinked && isGoogleAuthenticated) {
        createdEvent = await addGoogleEvent(availabilityEvent);
      } else {
        createdEvent = await createEvent(availabilityEvent);
      }
      
      console.log("Created event:", createdEvent);
      
      if (!createdEvent) {
        throw new Error("Failed to create availability event");
      }
      
      toast({
        title: "Availability Added",
        description: "Weekly availability slot has been added",
      });
      
      // Reset hasNoEvents flag since we just added an event
      setHasNoEvents(false);
      
      // Refresh events to show the new slot
      await refreshEvents();
    } catch (error) {
      console.error("Error adding availability slot:", error);
      toast({
        title: "Error",
        description: "Failed to add availability slot: " + (error instanceof Error ? error.message : String(error)),
        variant: "destructive",
      });
      throw error; // Re-throw to be handled by the caller
    }
  }, [clinicianId, createEvent, refreshEvents, toast, isGoogleLinked, isGoogleAuthenticated, addGoogleEvent, isInitialized, isAuthenticated]);
  
  const updateAvailabilitySlot = async (eventId: string, startTime: string, endTime: string) => {
    if (!clinicianId) {
      console.error("No clinician selected");
      return;
    }
    
    try {
      console.log(`Updating availability slot ${eventId}`);
      
      // Find the event to update
      const event = events.find(e => e.id === eventId);
      if (!event) {
        console.error("Event not found:", eventId);
        return;
      }
      
      // Create a date string from the event's start date
      let dateStr: string;
      if (typeof event.start === 'string') {
        dateStr = event.start.split('T')[0];
      } else if (event.start instanceof Date) {
        dateStr = format(event.start, 'yyyy-MM-dd');
      } else {
        dateStr = format(new Date(), 'yyyy-MM-dd');
      }
      
      // Create ISO datetime strings
      const startISO = `${dateStr}T${startTime}:00`;
      const endISO = `${dateStr}T${endTime}:00`;
      
      console.log(`Updating event with start time ${startISO} and end time ${endISO}`);
      
      // Create an updated event object
      const updatedEvent: ICalendarEvent = {
        id: eventId,
        clinicianId,
        title: event.title,
        startTime: startISO,
        endTime: endISO,
        allDay: false,
        eventType: 'availability',
      };
      
      // If this is a recurring event, keep the recurrence rule
      if (event.extendedProps?.recurrenceRule) {
        updatedEvent.recurrenceRule = event.extendedProps.recurrenceRule;
      }
      
      console.log("Updating event:", updatedEvent);
      
      // Update the event - in Google if linked, otherwise just locally
      if (isGoogleLinked && isGoogleAuthenticated && event.extendedProps?.googleEventId) {
        await updateGoogleEvent(updatedEvent);
      } else {
        await updateEvent(updatedEvent);
      }
      
      toast({
        title: "Availability Updated",
        description: "Availability slot has been updated",
      });
      
      // Refresh to show updated availability
      await refreshEvents();
    } catch (error) {
      console.error("Error updating availability slot:", error);
      toast({
        title: "Error",
        description: "Failed to update availability slot: " + (error instanceof Error ? error.message : String(error)),
        variant: "destructive",
      });
    }
  };
  
  const removeAvailabilitySlot = async (eventId: string) => {
    try {
      console.log(`Removing availability slot ${eventId}`);
      
      const event = events.find(e => e.id === eventId);
      
      // Delete from Google if linked, otherwise just locally
      if (isGoogleLinked && isGoogleAuthenticated && event?.extendedProps?.googleEventId) {
        await deleteGoogleEvent(eventId);
      } else {
        await deleteEvent(eventId);
      }
      
      toast({
        title: "Availability Removed",
        description: "Availability slot has been removed",
      });
      
      // Refresh to show updated availability
      await refreshEvents();
    } catch (error) {
      console.error("Error removing availability slot:", error);
      toast({
        title: "Error",
        description: "Failed to remove availability slot: " + (error instanceof Error ? error.message : String(error)),
        variant: "destructive",
      });
    }
  };

  // Refresh events when the clinician changes or initialization completes
  useEffect(() => {
    if (clinicianId && isInitialized && isAuthenticated) {
      console.log('[AvailabilityContext] Clinician or initialization changed, refreshing events');
      refreshEvents();
    }
  }, [clinicianId, refreshEvents, isInitialized, isAuthenticated]);

  // Provide a value object with authentication and initialization state
  const value = {
    events,
    isLoading: isLoading || !isInitialized || isUserLoading || isTimeZoneLoading,
    isInitialized,
    refreshEvents,
    addAvailabilitySlot,
    updateAvailabilitySlot,
    removeAvailabilitySlot,
    isGoogleLinked,
    isGoogleAuthenticated,
    connectGoogleCalendar,
    disconnectGoogleCalendar,
    syncWithGoogleCalendar,
    isSyncing,
    lastSyncTime,
    hasNoEvents,
    error
  };

  return (
    <AvailabilityContext.Provider value={value}>
      {children}
    </AvailabilityContext.Provider>
  );
};

export const useAvailability = () => {
  const context = useContext(AvailabilityContext);
  if (context === undefined) {
    throw new Error('useAvailability must be used within an AvailabilityProvider');
  }
  return context;
};
