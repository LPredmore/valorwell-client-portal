-- Table: calendar_events (Used for storing availability slots)
CREATE TABLE public.calendar_events (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    clinician_id uuid NOT NULL,
    title text NOT NULL,
    description text,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone NOT NULL,
    all_day boolean DEFAULT false,
    event_type text NOT NULL,
    recurrence_id uuid,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    is_active boolean NOT NULL DEFAULT true,
    google_event_id text,
    availability_type text,
    display_color text,
    time_zone text DEFAULT 'America/Chicago'::text,
    source_time_zone text DEFAULT 'America/Chicago'::text,
    
    CONSTRAINT calendar_events_pkey PRIMARY KEY (id),
    CONSTRAINT calendar_events_clinician_id_fkey FOREIGN KEY (clinician_id) REFERENCES profiles(id) ON DELETE CASCADE,
    CONSTRAINT calendar_events_recurrence_id_fkey FOREIGN KEY (recurrence_id) REFERENCES recurrence_rules(id),
    CONSTRAINT calendar_events_event_type_check CHECK ((event_type = ANY (ARRAY['availability'::text, 'appointment'::text, 'time_off'::text]))),
    CONSTRAINT calendar_events_check CHECK (
        CASE
            WHEN (event_type = 'availability'::text) THEN (availability_type = ANY (ARRAY['recurring'::text, 'single'::text]))
            ELSE true
        END
    ),
    CONSTRAINT availability_type_required CHECK (
        CASE
            WHEN (event_type = 'availability'::text) THEN (availability_type IS NOT NULL)
            ELSE true
        END
    )
);

-- Indexes to optimize queries
CREATE INDEX calendar_events_start_time_idx ON public.calendar_events USING btree (start_time);
CREATE INDEX calendar_events_end_time_idx ON public.calendar_events USING btree (end_time);
CREATE INDEX calendar_events_clinician_id_idx ON public.calendar_events USING btree (clinician_id);
CREATE INDEX idx_calendar_events_clinician_type ON public.calendar_events USING btree (clinician_id, event_type);
CREATE INDEX idx_calendar_events_date_range ON public.calendar_events USING btree (start_time, end_time);
CREATE INDEX idx_calendar_events_google_event_id ON public.calendar_events USING btree (google_event_id);
CREATE INDEX idx_calendar_events_availability ON public.calendar_events USING btree (event_type, availability_type) WHERE (event_type = 'availability'::text);
CREATE INDEX calendar_events_clinician_date_range_idx ON public.calendar_events USING btree (clinician_id, start_time, end_time);
CREATE INDEX calendar_events_date_range_idx ON public.calendar_events USING btree (start_time, end_time);

-- Row-Level Security (RLS) policies
ALTER TABLE public.calendar_events ENABLE ROW LEVEL SECURITY;

-- RLS policy: Clinician can view own availability
CREATE POLICY "Clinician can view own availability" 
    ON public.calendar_events
    FOR SELECT
    USING ((event_type = 'availability'::text) AND ((clinician_id)::text = (auth.uid())::text));

-- RLS policy: Clinician can insert own availability
CREATE POLICY "Clinician can insert own availability" 
    ON public.calendar_events
    FOR INSERT
    WITH CHECK ((event_type = 'availability'::text) AND ((clinician_id)::text = (auth.uid())::text));

-- RLS policy: Clinician can update own availability
CREATE POLICY "Clinician can update own availability" 
    ON public.calendar_events
    FOR UPDATE
    USING ((event_type = 'availability'::text) AND ((clinician_id)::text = (auth.uid())::text));

-- RLS policy: Clinician can delete own availability
CREATE POLICY "Clinician can delete own availability" 
    ON public.calendar_events
    FOR DELETE
    USING ((event_type = 'availability'::text) AND ((clinician_id)::text = (auth.uid())::text));

-- RLS policy: Clinicians can manage their own availability
CREATE POLICY "Clinicians can manage their own availability" 
    ON public.calendar_events
    FOR ALL
    USING (((event_type = 'availability'::text) AND ((clinician_id)::text = (auth.uid())::text)) OR (event_type <> 'availability'::text));

-- RLS policy: Admin access
CREATE POLICY "Enable all access for admin users" 
    ON public.calendar_events
    FOR ALL
    USING (is_admin());

-- Related functions for validation and integrity

-- Function: validate_calendar_event - Ensures calendar events have proper constraints
CREATE OR REPLACE FUNCTION public.validate_calendar_event()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.start_time >= NEW.end_time THEN
    RAISE EXCEPTION 'Start time must be before end time';
  END IF;
  
  IF NEW.event_type = 'availability' AND (
    NEW.start_time IS NULL OR 
    NEW.end_time IS NULL OR 
    NEW.clinician_id IS NULL
  ) THEN
    RAISE EXCEPTION 'Missing required fields for availability';
  END IF;
  
  RETURN NEW;
END;
$function$;

-- Function: prevent_overlapping_availability - Prevents booking overlaps
CREATE OR REPLACE FUNCTION public.prevent_overlapping_availability()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  debug_info JSONB;
BEGIN
  -- Only check for overlaps if this is an active availability event
  IF NEW.event_type = 'availability' AND NEW.is_active = TRUE THEN
    -- Store debug information for better troubleshooting
    debug_info := jsonb_build_object(
      'event_id', NEW.id,
      'start_time', NEW.start_time,
      'end_time', NEW.end_time,
      'recurrence_id', NEW.recurrence_id,
      'availability_type', NEW.availability_type
    );

    -- Different checks based on availability type
    IF NEW.availability_type = 'single' THEN
      -- For single events, check overlap with both single and recurring
      IF EXISTS (
        SELECT 1 FROM public.calendar_events
        WHERE 
          clinician_id = NEW.clinician_id
          AND event_type = 'availability'
          AND is_active = TRUE
          AND id <> COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
          AND (
            -- Standard overlap check
            (NEW.start_time < end_time AND NEW.end_time > start_time)
          )
      ) THEN
        RAISE EXCEPTION 'Overlapping availability slot detected for single event. Please choose a different time.';
      END IF;
    ELSIF NEW.availability_type = 'recurring' THEN
      -- For recurring events, we only check the base events against other base events
      -- Specific instances of recurring events are handled through exceptions
      IF EXISTS (
        SELECT 1 FROM public.calendar_events
        WHERE 
          clinician_id = NEW.clinician_id
          AND event_type = 'availability'
          AND is_active = TRUE
          AND id <> COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
          AND availability_type = 'recurring'
          AND (
            -- Standard overlap check but only compare the first instance
            (NEW.start_time < end_time AND NEW.end_time > start_time)
          )
      ) THEN
        RAISE EXCEPTION 'Overlapping recurring availability slots detected. Please check your recurring schedule.';
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$function$;

-- Triggers for validation
CREATE TRIGGER check_availability_overlap
  BEFORE INSERT OR UPDATE ON public.calendar_events
  FOR EACH ROW
  EXECUTE FUNCTION prevent_overlapping_availability();

CREATE TRIGGER validate_calendar_event
  BEFORE INSERT OR UPDATE ON public.calendar_events
  FOR EACH ROW
  EXECUTE FUNCTION validate_calendar_event();

-- Related tables for availability management:

-- 1. Table: recurrence_rules (Stores recurring availability patterns)
CREATE TABLE public.recurrence_rules (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    event_id uuid,
    rrule text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    
    CONSTRAINT recurrence_rules_pkey PRIMARY KEY (id)
);

-- Index for recurrence_rules
CREATE INDEX recurrence_rules_event_id_idx ON public.recurrence_rules USING btree (event_id);

-- 2. Table: calendar_exceptions (Handles exceptions to recurring availability)
CREATE TABLE public.calendar_exceptions (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    recurrence_event_id uuid,
    exception_date timestamp with time zone NOT NULL,
    is_cancelled boolean DEFAULT false,
    replacement_event_id uuid,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    
    CONSTRAINT calendar_exceptions_pkey PRIMARY KEY (id)
);

-- 3. Table: availability_settings (Clinician-specific availability settings)
CREATE TABLE public.availability_settings (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    clinician_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    default_slot_duration integer NOT NULL DEFAULT 60,
    max_advance_days integer NOT NULL DEFAULT 30,
    min_notice_days integer NOT NULL DEFAULT 1,
    time_zone text DEFAULT 'America/Chicago'::text,
    slot_duration integer DEFAULT 60,
    time_granularity text DEFAULT 'hour'::text,
    is_active boolean DEFAULT true,
    
    CONSTRAINT availability_settings_pkey PRIMARY KEY (id)
);










Explanation:
Availability Storage Structure
In this system, instead of having a dedicated availability_slots table, availability is implemented within the multi-purpose calendar_events table using the following design:

Event Type Differentiation:

event_type = 'availability' identifies records as availability slots
availability_type specifies whether it's a 'recurring' or 'single' availability
Data Fields:

clinician_id - Links to the clinician who owns the availability
start_time and end_time - When the clinician is available
is_active - Whether the availability is currently active
time_zone - The time zone of the availability
Recurring Availability Flow:
A record is created in calendar_events with event_type = 'availability' and availability_type = 'recurring'
A corresponding record is created in recurrence_rules with a valid RRULE string (e.g., FREQ=WEEKLY;BYDAY=MO)
Exceptions to recurring availability are stored in the calendar_exceptions table
Data Integrity:
Validation Triggers:

validate_calendar_event() ensures required fields are present
prevent_overlapping_availability() prevents booking conflicts
Row-Level Security (RLS):

Clinicians can only manage their own availability
Admin users have full access
Settings and Configuration:
The availability_settings table contains clinician-specific settings like:

Default appointment slot duration
How far in advance appointments can be booked
Minimum notice required for appointments
Time zone preferences
This SQL export represents the complete implementation of availability management in your calendar system, and should provide another developer with a comprehensive understanding of how it works.